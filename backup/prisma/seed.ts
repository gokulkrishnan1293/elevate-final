// prisma/seed.ts
import { PrismaClient } from '@prisma/client';
import { faker } from '@faker-js/faker';

const prisma = new PrismaClient();

const NUM_EMPLOYEES_TO_GENERATE = 50; // Adjust as needed
const ORG_OWNERS_PER_ORG = 2;
const ART_LEADS_PER_ART = 3;
const TEAM_OWNERS_PER_TEAM = 3;

async function main() {
  console.log('Starting seeding process...');

  // --- 1. Fetch Existing Data ---
  console.log('Fetching existing Organizations, ARTs, and Teams...');
  const organizations = await prisma.organization.findMany({ select: { id: true } });
  const arts = await prisma.aRT.findMany({ select: { id: true } });
  const teams = await prisma.team.findMany({ select: { id: true } });

  if (organizations.length === 0) {
    console.warn('No organizations found. Skipping Org Owner assignment.');
  }
  if (arts.length === 0) {
    console.warn('No ARTs found. Skipping ART Lead assignment.');
  }
  if (teams.length === 0) {
    console.warn('No teams found. Skipping Team Owner assignment.');
  }

  // --- 2. Generate Dummy Employees ---
  console.log(`Generating ${NUM_EMPLOYEES_TO_GENERATE} dummy employees...`);
  const createdEmployeeIds: number[] = [];
  const employeePromises = [];

  for (let i = 0; i < NUM_EMPLOYEES_TO_GENERATE; i++) {
    const firstName = faker.person.firstName();
    const lastName = faker.person.lastName();
    const email = faker.internet.email({ firstName, lastName, provider: 'example.com' }).toLowerCase();
    // Ensure lanId is unique enough for seeding purposes
    const lanId = `${firstName.charAt(0)}${lastName}${faker.string.alphanumeric(4)}`.toLowerCase();

    employeePromises.push(
      prisma.employee.create({
        data: {
          name: `${firstName} ${lastName}`,
          email: email,
          lanId: lanId,
          isContractor: faker.datatype.boolean(0.2), // 20% chance of being contractor
          // cignaManagerId: null, // Assuming no manager initially
          updatedAt: new Date(), // Required by schema check
          isUserActive: true,
        },
        select: { id: true }, // Select only the ID after creation
      })
    );
  }

  try {
      const createdEmployees = await Promise.all(employeePromises);
      createdEmployeeIds.push(...createdEmployees.map(emp => emp.id));
      console.log(`Successfully created ${createdEmployeeIds.length} employees.`);
  } catch (error: any) {
      console.error("Error creating employees:", error);
      // Check for unique constraint violation specifically
      if (error.code === 'P2002') {
          console.error(`Failed due to unique constraint violation. Potential duplicate email or lanId generated by faker. Try running the seed again.`);
      }
      throw error; // Re-throw to stop the script
  }


  if (createdEmployeeIds.length === 0) {
      console.error("No employees were created or fetched. Cannot assign roles.");
      return;
  }

  // Helper function to get unique random elements
  function getRandomUniqueElements<T>(arr: T[], count: number): T[] {
    if (count > arr.length) {
      console.warn(`Warning: Requested ${count} elements, but only ${arr.length} available. Returning all available.`);
      return [...arr]; // Return a shuffled copy
    }
    const shuffled = arr.sort(() => 0.5 - Math.random());
    return shuffled.slice(0, count);
  }

  // --- 3. Assign Organization Owners ---
  if (organizations.length > 0) {
    console.log('Assigning Organization Owners...');
    const orgLinkPromises = [];
    for (const org of organizations) {
      const owners = getRandomUniqueElements(createdEmployeeIds, ORG_OWNERS_PER_ORG);
      for (const ownerId of owners) {
        orgLinkPromises.push(
          prisma.employeeOrgLink.upsert({ // Use upsert to avoid errors if link exists
            where: { employeeId_organizationId_role: { employeeId: ownerId, organizationId: org.id, role: 'Owner' } },
            update: {}, // No update needed if it exists
            create: {
              employeeId: ownerId,
              organizationId: org.id,
              role: 'Owner',
            },
          })
        );
      }
    }
     try {
        await Promise.all(orgLinkPromises);
        console.log('Organization Owners assigned.');
    } catch (error) {
        console.error("Error assigning Org Owners:", error);
        // Continue if possible, or re-throw based on severity
    }
  }

  // --- 4. Assign ART Leads ---
   if (arts.length > 0) {
    console.log('Assigning ART Leads...');
    const artLinkPromises = [];
    for (const art of arts) {
      const leads = getRandomUniqueElements(createdEmployeeIds, ART_LEADS_PER_ART);
      for (const leadId of leads) {
         artLinkPromises.push(
           prisma.employeeARTLink.upsert({ // Use upsert
            where: { employeeId_artId_role: { employeeId: leadId, artId: art.id, role: 'Lead' } },
            update: {},
            create: {
              employeeId: leadId,
              artId: art.id,
              role: 'Lead', // Example role
            },
          })
        );
      }
    }
     try {
        await Promise.all(artLinkPromises);
        console.log('ART Leads assigned.');
    } catch (error) {
        console.error("Error assigning ART Leads:", error);
    }
  }

  // --- 5. Assign Team Owners ---
  if (teams.length > 0) {
    console.log('Assigning Team Owners...');
    const teamLinkPromises = [];
    const teamOwnershipCount: { [employeeId: number]: number } = {};
    let multiTeamOwners = 0;

    // Ensure we have enough employees for the multi-owner requirement
    const requiredEmployeesForMultiOwner = 2;
    const potentialMultiOwners = getRandomUniqueElements(createdEmployeeIds, requiredEmployeesForMultiOwner);

    for (const team of teams) {
      let owners = getRandomUniqueElements(createdEmployeeIds, TEAM_OWNERS_PER_TEAM);

      // Try to assign potential multi-owners first if needed
      if (multiTeamOwners < requiredEmployeesForMultiOwner && potentialMultiOwners.length > 0) {
         const ownerToAssign = potentialMultiOwners.pop(); // Take one potential multi-owner
         if (ownerToAssign && !owners.includes(ownerToAssign)) {
             owners.pop(); // Remove one random owner
             owners.push(ownerToAssign); // Add the designated multi-owner
         }
      }

      for (const ownerId of owners) {
        teamLinkPromises.push(
          prisma.employeeTeamLink.upsert({ // Use upsert
            where: { employeeId_teamId: { employeeId: ownerId, teamId: team.id } },
            update: { isTeamOwner: true }, // Ensure they are owner if link exists
            create: {
              employeeId: ownerId,
              teamId: team.id,
              jobTitle: faker.person.jobTitle(), // Assign a random job title
              isTeamOwner: true,
            },
          })
        );
        // Track ownership counts
        teamOwnershipCount[ownerId] = (teamOwnershipCount[ownerId] || 0) + 1;
        if (teamOwnershipCount[ownerId] === 2) { // Count when they reach *exactly* 2 teams
            multiTeamOwners++;
        }
      }
    }
     try {
        await Promise.all(teamLinkPromises);
        console.log(`Team Owners assigned. Found ${multiTeamOwners} employees owning multiple teams.`);
        if (multiTeamOwners < requiredEmployeesForMultiOwner) {
            console.warn(`Could not ensure ${requiredEmployeesForMultiOwner} employees own multiple teams. Only ${multiTeamOwners} do. This might happen with few teams or employees.`);
        }
    } catch (error) {
        console.error("Error assigning Team Owners:", error);
    }
  }

  console.log('Seeding finished.');
}

main()
  .catch((e) => {
    console.error('An error occurred during seeding:', e);
    process.exit(1);
  })
  .finally(async () => {
    await prisma.$disconnect();
    console.log('Prisma client disconnected.');
  });